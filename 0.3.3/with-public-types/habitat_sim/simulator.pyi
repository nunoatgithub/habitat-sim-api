from _typeshed import Incomplete
from habitat_sim.agent.agent import Agent as Agent, AgentConfiguration as AgentConfiguration, AgentState as AgentState
from habitat_sim.bindings import cuda_enabled as cuda_enabled
from habitat_sim.logging import LoggingContext as LoggingContext, logger as logger
from habitat_sim.metadata import MetadataMediator as MetadataMediator
from habitat_sim.nav import GreedyGeodesicFollower as GreedyGeodesicFollower
from habitat_sim.sensor import SensorSpec as SensorSpec, SensorType as SensorType
from habitat_sim.sensors.noise_models import make_sensor_noise_model as make_sensor_noise_model
from habitat_sim.sim import SimulatorBackend as SimulatorBackend, SimulatorConfiguration as SimulatorConfiguration
from habitat_sim.utils.common import quat_from_angle_axis as quat_from_angle_axis
from magnum import Vector3
from numpy import ndarray as ndarray
from torch import Tensor as Tensor
from typing import Any, Dict, List, MutableMapping as MutableMapping_T, overload

ObservationDict: Incomplete

class Configuration:
    sim_cfg: SimulatorConfiguration
    agents: List[AgentConfiguration]
    metadata_mediator: MetadataMediator | None
    enable_batch_renderer: bool

class Simulator(SimulatorBackend):
    config: Configuration
    agents: List[Agent]
    def __attrs_post_init__(self) -> None: ...
    def close(self, destroy: bool = True) -> None: ...
    def __enter__(self) -> Simulator: ...
    def __exit__(self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: types.TracebackType | None) -> None: ...
    def seed(self, new_seed: int) -> None: ...
    @overload
    def reset(self, agent_ids: List[int]) -> Dict[int, ObservationDict]: ...
    @overload
    def reset(self, agent_ids: int | None = None) -> ObservationDict: ...
    def reset_agent(self, agent_id: int) -> None: ...
    def reconfigure(self, config: Configuration) -> None: ...
    def add_sensor(self, sensor_spec: SensorSpec, agent_id: int | None = None) -> None: ...
    def get_agent(self, agent_id: int) -> Agent: ...
    def initialize_agent(self, agent_id: int, initial_state: AgentState | None = None) -> Agent: ...
    def start_async_render_and_step_physics(self, dt: float, agent_ids: int | List[int] = 0): ...
    def start_async_render(self, agent_ids: int | List[int] = 0): ...
    def get_sensor_observations_async_finish(self) -> Dict[str, ndarray | Tensor] | Dict[int, Dict[str, ndarray | Tensor]]: ...
    @overload
    def get_sensor_observations(self, agent_ids: int = 0) -> ObservationDict: ...
    @overload
    def get_sensor_observations(self, agent_ids: List[int]) -> Dict[int, ObservationDict]: ...
    def last_state(self, agent_id: int | None = None) -> AgentState: ...
    @overload
    def step(self, action: str | int, dt: float = ...) -> ObservationDict: ...
    @overload
    def step(self, action: MutableMapping_T[int, str | int], dt: float = ...) -> Dict[int, ObservationDict]: ...
    def make_greedy_follower(self, agent_id: int | None = None, goal_radius: float | None = None, *, stop_key: Any | None = None, forward_key: Any | None = None, left_key: Any | None = None, right_key: Any | None = None, fix_thrashing: bool = True, thrashing_threshold: int = 16): ...
    def step_filter(self, start_pos: Vector3, end_pos: Vector3) -> Vector3: ...
    def __del__(self) -> None: ...
    def step_physics(self, dt: float) -> None: ...

class Sensor:
    buffer: Incomplete
    def __init__(self, sim: Simulator, agent: Agent, sensor_id: str) -> None: ...
    def draw_observation(self) -> None: ...
    def get_observation(self) -> ndarray | Tensor: ...
    def close(self) -> None: ...
