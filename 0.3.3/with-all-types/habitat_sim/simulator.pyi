from _typeshed import Incomplete
from habitat_sim.agent.agent import Agent as Agent, AgentConfiguration as AgentConfiguration, AgentState as AgentState
from habitat_sim.bindings import cuda_enabled as cuda_enabled
from habitat_sim.logging import LoggingContext as LoggingContext, logger as logger
from habitat_sim.metadata import MetadataMediator as MetadataMediator
from habitat_sim.nav import GreedyGeodesicFollower as GreedyGeodesicFollower
from habitat_sim.sensor import SensorSpec as SensorSpec, SensorType as SensorType
from habitat_sim.sensors.noise_models import make_sensor_noise_model as make_sensor_noise_model
from habitat_sim.sim import SimulatorBackend as SimulatorBackend, SimulatorConfiguration as SimulatorConfiguration
from habitat_sim.utils.common import quat_from_angle_axis as quat_from_angle_axis
from magnum import Vector3
from numpy import ndarray as ndarray
from torch import Tensor as Tensor
from typing import Any, Dict, List, MutableMapping as MutableMapping_T, overload

_HAS_TORCH: bool
ObservationDict: Incomplete

class Configuration:
    sim_cfg: SimulatorConfiguration
    agents: List[AgentConfiguration]
    metadata_mediator: MetadataMediator | None
    enable_batch_renderer: bool

class Simulator(SimulatorBackend):
    config: Configuration
    agents: List[Agent]
    _num_total_frames: int
    _default_agent_id: int
    __sensors: List[Dict[str, 'Sensor']]
    _initialized: bool
    _previous_step_time: float
    _async_draw_agent_ids: int | List[int] | None
    __last_state: Dict[int, AgentState]
    @staticmethod
    def _sanitize_config(config: Configuration) -> None: ...
    def __attrs_post_init__(self) -> None: ...
    def close(self, destroy: bool = True) -> None: ...
    def __enter__(self) -> Simulator: ...
    def __exit__(self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: types.TracebackType | None) -> None: ...
    def seed(self, new_seed: int) -> None: ...
    @overload
    def reset(self, agent_ids: List[int]) -> Dict[int, ObservationDict]: ...
    @overload
    def reset(self, agent_ids: int | None = None) -> ObservationDict: ...
    def reset_agent(self, agent_id: int) -> None: ...
    def _config_backend(self, config: Configuration) -> None: ...
    def _config_agents(self, config: Configuration) -> None: ...
    def _config_pathfinder(self, config: Configuration) -> None: ...
    def reconfigure(self, config: Configuration) -> None: ...
    frustum_culling: Incomplete
    def __set_from_config(self, config: Configuration) -> None: ...
    def _update_simulator_sensors(self, uuid: str, agent_id: int) -> None: ...
    def add_sensor(self, sensor_spec: SensorSpec, agent_id: int | None = None) -> None: ...
    def get_agent(self, agent_id: int) -> Agent: ...
    def initialize_agent(self, agent_id: int, initial_state: AgentState | None = None) -> Agent: ...
    def start_async_render_and_step_physics(self, dt: float, agent_ids: int | List[int] = 0): ...
    def start_async_render(self, agent_ids: int | List[int] = 0): ...
    def get_sensor_observations_async_finish(self) -> Dict[str, ndarray | Tensor] | Dict[int, Dict[str, ndarray | Tensor]]: ...
    @overload
    def get_sensor_observations(self, agent_ids: int = 0) -> ObservationDict: ...
    @overload
    def get_sensor_observations(self, agent_ids: List[int]) -> Dict[int, ObservationDict]: ...
    @property
    def _default_agent(self) -> Agent: ...
    @property
    def _last_state(self) -> AgentState: ...
    @_last_state.setter
    def _last_state(self, state: AgentState) -> None: ...
    @property
    def _sensors(self) -> Dict[str, 'Sensor']: ...
    def last_state(self, agent_id: int | None = None) -> AgentState: ...
    @overload
    def step(self, action: str | int, dt: float = ...) -> ObservationDict: ...
    @overload
    def step(self, action: MutableMapping_T[int, str | int], dt: float = ...) -> Dict[int, ObservationDict]: ...
    def make_greedy_follower(self, agent_id: int | None = None, goal_radius: float | None = None, *, stop_key: Any | None = None, forward_key: Any | None = None, left_key: Any | None = None, right_key: Any | None = None, fix_thrashing: bool = True, thrashing_threshold: int = 16): ...
    def step_filter(self, start_pos: Vector3, end_pos: Vector3) -> Vector3: ...
    def __del__(self) -> None: ...
    def step_physics(self, dt: float) -> None: ...

class Sensor:
    buffer: Incomplete
    _sim: Incomplete
    _agent: Incomplete
    _sensor_object: Incomplete
    _spec: Incomplete
    def __init__(self, sim: Simulator, agent: Agent, sensor_id: str) -> None: ...
    _buffer: Incomplete
    view: Incomplete
    _noise_model: Incomplete
    def _initialize_sensor(self) -> None: ...
    def draw_observation(self) -> None: ...
    def _draw_observation_async(self) -> None: ...
    def get_observation(self) -> ndarray | Tensor: ...
    def _get_observation_async(self) -> ndarray | Tensor: ...
    def _get_audio_observation(self) -> ndarray | Tensor: ...
    def close(self) -> None: ...
